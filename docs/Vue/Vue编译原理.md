---
status: be-editing
---

# Vue 编译原理

## 什么是编译？

提到编译，相信不少读者都会觉得是一件很神秘的事情，本文就通过分析 Vue 的编译原理，来掀开它的神秘面纱。

什么是**编译（compile）**呢？在 Vue 中，我们通常说的编译就是指将模板中的代码转为可用的 render 函数，也就是将 html 代码转为了 js 代码。所以我们可以理解编译就是将一种语言 ==转变==> 另一种语言。而这个被转变的就称之为源码（source code），转变后得到的结果，就称之为目标代码（target code）。

而一个语言要转变为一种新的语言，我们要通过什么手段呢？粗暴的关键词映射或者字符串替换吗？在编程中，虽然不可避免的存在硬编码，但是我们一定会通过各种手段来进行优化，让硬编码尽可能的少，而这两个方法，很明显，就是一种非常糟糕的硬编码。

设想一下，如果把一段中文翻译为英文，如果直接按照词语的顺序直翻，那么不少时候，一段句子的语义可能都是显得比较奇怪的。所以通常不会逐字替换，而是会先理解这段话的意思和结构：哪些是主语、哪些是谓语、哪些是修饰成分。然后再用英文的语法规则重新组织这些内容。

编译也是同样的道理。我们需要一个"中间形式"来表达源码的结构和语义，这个中间形式就是 **抽象语法树（Abstract Syntax Tree，简称 AST）**。

实际上，在计算机科学中，编译过程通常被分为几个关键步骤：
1. **词法分析**：将代码字符串分解成一个个有意义的词法单元（token）
2. **语法分析**：将这些词法单元组织成一个树形结构，这个结构就是 **抽象语法树（Abstract Syntax Tree，简称 AST）**
3. 中间代码生成、优化...（有些编译过程会有这些步骤）
4. **代码生成**：基于 AST 生成目标代码

可以看到，AST 在编译过程中扮演着承上启下的关键角色，它就像一座桥梁，连接着源码和目标代码。

如果对上面的步骤进行一些拆分，那么大致可以分为两个部分，编译前端和编译后端：

- 编译前端: 通常与目标平台无关，仅负责分析源码。
- 编译后端: 通常与目标平台相关，负责生成能够运行的平台代码。

![image-20251218101936666](./Vue编译原理.assets/image-20251218101936666.png)

## 什么是 AST？

前面我们多次提到了 AST（抽象语法树），但它到底长什么样呢？为什么要叫"树"，又为什么要叫"抽象"？

首先，让我们通过一个简单的例子来理解什么是"树"。假设我们有这样一个简单的算术表达式：

```
2 + 3 * 4
```

我们都知道，这个表达式的计算结果是 `14`，而不是 `20`，因为乘法的优先级高于加法。那么在程序中，我们如何表达这种优先级关系呢？答案就是用**树形结构**：

```
        +
       / \
      2   *
         / \
        3   4
```

可以看到，这个树形结构清晰地表达了运算的优先级：先计算 `3 * 4`，再将结果与 `2` 相加。这就是为什么叫"树"——它用**层级关系**来表达代码的**结构和优先级**。

那为什么又叫"抽象"呢？因为这棵树只保留了代码的核心结构和语义，而**省略了一些语法细节**。比如在上面的树中，我们看不到空格、看不到表达式从左往右的书写顺序，只保留了最核心的信息：有两个操作符（`+` 和 `*`），三个操作数（`2`、`3`、`4`），以及它们之间的层级关系。

在实际的编程中，AST 通常用对象来表示。上面的算术表达式对应的 AST 可能是这样的：

```js
{
  type: 'BinaryExpression',    // 二元表达式
  operator: '+',
  left: {
    type: 'Literal',           // 字面量
    value: 2
  },
  right: {
    type: 'BinaryExpression',
    operator: '*',
    left: {
      type: 'Literal',
      value: 3
    },
    right: {
      type: 'Literal',
      value: 4
    }
  }
}
```

可以看到，每个 AST 节点都包含了几个关键信息：
- **type（类型）**：这个节点是什么类型的语法结构（表达式、语句、字面量等）
- **属性**：这个节点的具体信息（比如操作符是 `+` 还是 `-`，字面量的值是多少）
- **子节点**：这个节点包含的子结构（比如二元表达式的左右操作数）

正是通过这种树形结构，编译器可以方便地遍历、分析和转换代码。比如要计算上面的表达式，只需要递归地计算子节点，然后根据操作符进行运算即可。

那么在 Vue 中，模板对应的 AST 又是什么样的呢？让我们接着往下看。

## 了解 Vue 编译流程
经过前文的解析，相信你对编译已经有了一些大概的理解，而 Vue 的模板编译也正是遵循了这样的流程。

回到文章开头提到的，Vue 的编译就是将模板（Template）转换为渲染函数（Render Function）。那么这个过程具体是如何进行的呢？让我们将前面学到的编译知识应用到 Vue 中：

举个例子，我们有这样一个 Vue 模板：

```vue
<div id="app">
  <p>{{ message }}</p>
</div>
```

Vue 最终会将它转换成类似这样的渲染函数：

```js
function render() {
  return _c('div', { attrs: { id: 'app' } }, [
    _c('p', [_v(_s(message))])
  ])
}
```

而变成这样大概会经过如下几个步骤，如图：

![image-20251218103223833](./Vue编译原理.assets/image-20251218103223833.png)

而这种步骤也在其它地方有所体现，比如 typescript --> javascript。那肯定大概流程就是 typescript --> typescript AST --> javascript AST --> javascript。当然，这种例子还有很多，就不一一列举了。

## Vue 编译之解析器
通过上面的赘述，不难猜到解析器的核心作用就是将模板代码变为 AST。 假设我们有下面一段模板代码:
```vue
<template>
    <div>
        <h1 :class="titleClass">Hello World</h1>
    </div>
</template>
```

上面这段代码，从我们看来，可能会有变量、标签、字符...的存在，而对于解析起来说，就是一段源码字符串，使用代码简单表示，如下:
```js
const sourceCode = `<template><div><h1 :class="titleClass">Hello World</h1></div></template>`
```

那么如何解析呢？如果你看过霍春阳大佬的《Vue.js 设计与实现》这本书，那么相信你一定不陌生。在这本里面，提出了一个概念**有限状态自动机**。

那么什么是有限状态自动机呢？有限状态自动机（Finite State Automaton，也称有限状态机）听起来好像很高大上，理解起来并不困难，"有限状态"指的是状态是有限的，"自动机"意味着随着字符的输入，解析器会自动地在不同状态间迁移。它的核心思想非常简单：**一个系统在任意时刻都处于某个特定的"状态"，当接收到不同的"输入"时，会"自动"转移到另一个"状态"**。这里的"自动"指的是状态转移是确定性的，遵循预先定义好的规则。

举个生活中的例子，想象一下你在使用一个简单的电灯开关：
- **初始状态**：灯是关闭的
- **输入**：按一下开关 → **状态转移** → 灯打开了
- **再输入**：再按一下开关 → **状态转移** → 灯关闭了

这个电灯系统就是一个简单的有限状态机，它只有两个状态（开/关），通过特定的输入（按开关）来切换状态。

那么在解析 HTML 模板时，有限状态机是如何工作的呢？我们可以把解析器想象成一个"读字符"的机器，它会从左往右逐个字符地读取模板字符串，根据当前读到的字符，来判断自己处于什么状态，然后决定下一步该做什么。

比如解析 `<div>Hello</div>` 这段代码时，解析器可能会经历这样的状态变化：

1. **"初始状态"** → 读到 `<` → 进入 **"标签开始"状态**
2. **"标签开始"状态** → 读到字母 `d` → 进入 **"标签名"状态**
3. **"标签名"状态** → 继续读到 `i`、`v`，拼接成标签名 `div`
4. **"标签名"状态** → 读到 `>` → **开始标签解析完成**，创建一个 `<div>` 元素节点，进入 **"文本内容"状态**
5. **"文本内容"状态** → 读到 `H`、`e`、`l`、`l`、`o`，拼接成文本内容 `Hello`
6. **"文本内容"状态** → 读到 `<` → 文本内容收集完成，进入 **"标签开始"状态**
7. **"标签开始"状态** → 读到 `/` → 判断这是一个结束标签，进入 **"结束标签名"状态**
8. **"结束标签名"状态** → 读到 `d`、`i`、`v` → 拼接成结束标签名 `div`
9. **"结束标签名"状态** → 读到 `>` → **结束标签解析完成**，与之前的开始标签 `<div>` 配对，完成该元素的解析

我们可以用一个简化的状态转换图来表示：

```
初始状态
   ↓ (读到 '<')
标签开始
   ↓ (读到字母)
标签名 (收集 "div")
   ↓ (读到 '>')
文本内容 (收集 "Hello")
   ↓ (读到 '<')
标签开始
   ↓ (读到 '/')
结束标签名 (收集 "div")
   ↓ (读到 '>')
完成解析
```

通过这种方式，解析器可以**精确地识别**模板中的每一个部分：哪些是开始标签、哪些是属性、哪些是文本内容、哪些是结束标签。而且，这种方法不需要复杂的正则表达式，也不需要回溯，只需要顺序读取字符，根据当前状态做出相应的处理即可，**效率非常高**。









